<h2 data-ke-size="size26">백준 2581번 소수 (C++)</h2>
<p data-ke-size="size16">이번에 풀어본 문제는 주어진 범위 내에서 소수(prime number)를 찾아 그 합과 최솟값을 구하는 <b>백준 2581번 소수</b> 문제입니다. 소수의 정의를 이용하여 간단한 반복문으로 해결할 수 있었습니다.</p>
<p data-ke-size="size16">문제는 아래 링크에서 확인할 수 있습니다.<br /><a href="https://www.acmicpc.net/problem/2581" target="_blank" rel="noopener noreferrer">백준 2581번 문제 바로가기</a></p>
<h3 id="💻-코드" data-ke-size="size23">💻 코드</h3>
<pre class="cpp" data-ke-language="cpp"><code>#include &lt;iostream&gt;

using namespace std;

int main(){
int m,n;
cin &gt;&gt; m &gt;&gt; n;

    int sum = 0;
    int mi = 1e9;
    
    if(m == 1){
        for(int i = 2; i &lt;= n; i++){
            bool b = 1;
            for(int t = 2; t &lt; i; t++){
                if(i % t == 0) {
                    b = 0;
                    break;
                }
            }
            if(b == 1){
                sum += i;
                mi = min(mi, i);
            }
        }
    }
    else{
        for(int i = m; i &lt;= n; i++){
            bool b = 1;
            for(int t = 2; t &lt; i; t++){
                if(i % t == 0) {
                    b = 0;
                    break;
                }
            }
            if(b == 1){
                sum += i;
                mi = min(mi, i);
            }
        }
    }

    if(sum == 0){
        cout &lt;&lt; -1;
        return 0;
    }

    cout &lt;&lt; sum &lt;&lt; "\n" &lt;&lt; mi;

}</code></pre>
<h3 id="🔍-로직-설명" data-ke-size="size23">🔍 로직 설명</h3>
<p data-ke-size="size16">간단하게 생각해서 m부터 n까지 탐색하면 2부터 나누어떨어지는지 아닌지 판별해서 도출하는 코드를 짰다. 1은 소수가 아니기에 1도 따로 if로 빼서 판단해줬다.<br />이렇게 풀어도 풀리긴하는데 시간복잡도가 조금 비효율적인거같다 - o(n^2)</p>
<p data-ke-size="size16">그래서 소수의 특징중에 약수 쌍의 작은 수는 그 수의 제곱근보다 작거나 같으니 그 범위까지만 탐색하는 방식이 있다<br />ex) 16의 약수 쌍 {1,16} {2,8} {4} 의 작은 수 1,2,4가 16의 제곱근 4를 넘지 않는 것처럼</p>
<p data-ke-size="size16">그래서 함수 sprt를 쓰면 <span> <span>O(n루트n)을 가진다</span></span></p>
<h3 id="✍️-느낀-점" data-ke-size="size23">✍️ 느낀 점</h3>
<p data-ke-size="size16">소수 판별할땐 sqrt를 써서 제곱근까지만 탐색하자</p>