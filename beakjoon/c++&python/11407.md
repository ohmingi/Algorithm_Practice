<h2 data-ke-size="size26">백준 11047번 동전 0 (C++)</h2>
<p data-ke-size="size16">이번에 풀어본 문제는 그리디(Greedy) 알고리즘의 가장 대표적인 예시 중 하나인 <b>백준 11047번 동전 0</b> 문제입니다. 가지고 있는 동전 종류를 이용해 특정 금액을 만드는 데 필요한 동전의 최소 개수를 구하는 문제입니다.</p>
<p data-ke-size="size16">문제는 아래 링크에서 확인할 수 있습니다.<br /><a href="https://www.acmicpc.net/problem/11047" target="_blank" rel="noopener noreferrer">백준 11047번 문제 바로가기</a></p>
<h3 id="💻-코드" data-ke-size="size23">💻 코드</h3>
<pre class="cpp"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main(){
&nbsp; &nbsp; int n,k;
&nbsp; &nbsp; cin &gt;&gt; n &gt;&gt; k;

&nbsp; &nbsp; vector&lt;int&gt; v(n+1);

&nbsp; &nbsp; for(int i = 1; i &lt; n + 1; i++){
&nbsp; &nbsp; &nbsp; &nbsp; cin &gt;&gt; v[i];
&nbsp; &nbsp; }

&nbsp; &nbsp; int c = 0;

&nbsp; &nbsp; for(int i = n; i &gt;= 1; i--){
&nbsp; &nbsp; &nbsp; &nbsp; if(k == 0) break;
&nbsp; &nbsp; &nbsp; &nbsp; if(k &gt;= v[i]){
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while(k &gt;= v[i]){
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c++;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k -= v[i];
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }

&nbsp; &nbsp; cout &lt;&lt; c;
}
</code></pre>
<h3 id="🔍-로직-설명" data-ke-size="size23">🔍 로직 설명</h3>
<p data-ke-size="size16">기본 문제부터 하나씩 풀고있기에 난이도가 낮은 문제들을 많이 풀고 있다. 그래도 수학이라는 특정한 식이나 공식같은걸 사용하는 문제 유형이다보니 쉬운문제라도 배우는 점들이 꽤 있는것 같다.<br />아무튼 이문제는 주어진 동전으로 k를 만드는 가장적은 개수를 찾는 문제인데 문제 조건에서 i가 커질수록 더 큰값을 가진다고 했음으로 최소갯수를 구하려면 제일 큰 동전부터 접근해서 최대한 k에 근접한 값을 만들고 그 다음 작은 동전으로 넘어가서 반복하는 문제이다.<br />난 while문을 써서 한번씩 계산해주었는데 그냥 나누기 연산이랑 나머지 연산해서 동전 몇개 썼는지, 그 동전들을 빼고나면 얼마가 남아있는지를 구하는게 더 코드가 효율적인거 같다 큰차이는 없긴하다</p>
<h3 id="✍️-느낀-점" data-ke-size="size23">✍️ 느낀 점</h3>
<p data-ke-size="size16">dp방식으로도 풀 수 있는 문제긴하다 각 동전마다 k값까지 dp값을 계속 최신화해서 풀면 되는데 시간복잡도가 o(n*k)이기에&nbsp;<br />이문제에서는 그다지 효율적이진 않다.</p>
<p data-ke-size="size16">원래방식으로 하면 o(n)</p></code></pre>