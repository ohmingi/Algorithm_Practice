<h2 data-ke-size="size26">백준 9020번 골드바흐의 추측 (C++)</h2>
<p data-ke-size="size16">이번에 풀어본 문제는 소수(prime number)와 관련된 유명한 미해결 문제인 <b>백준 9020번 골드바흐의 추측</b>입니다. 주어진 짝수를 두 소수의 합으로 나타내는 문제로, 여러 쌍이 나올 경우 두 소수의 차이가 가장 작은 쌍을 출력해야 합니다.</p>
<p data-ke-size="size16">문제는 아래 링크에서 확인할 수 있습니다.<br /><a href="https://www.acmicpc.net/problem/9020" target="_blank" rel="noopener noreferrer">백준 9020번 문제 바로가기</a></p>
<h3 id="💻-코드" data-ke-size="size23">💻 코드</h3>
<pre class="cpp"><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

bool dec(int a){
&nbsp; &nbsp; if(a &lt; 2) return false;
&nbsp; &nbsp;
&nbsp; &nbsp; for(int i = 2; i*i &lt;= a; i++){
&nbsp; &nbsp; &nbsp; &nbsp; if(a % i == 0){
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }

&nbsp; &nbsp; return true;
}

int main(){
&nbsp; &nbsp; int n;
&nbsp; &nbsp; cin &gt;&gt; n;

&nbsp; &nbsp; int arr[2];

&nbsp; &nbsp; while(n--){
&nbsp; &nbsp; &nbsp; &nbsp; int a;
&nbsp; &nbsp; &nbsp; &nbsp; cin &gt;&gt; a;

&nbsp; &nbsp; &nbsp; &nbsp; for(int i = 2; i &lt;= a/2; i++){
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(dec(i) &amp;&amp; dec(a-i)){
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arr[0] = i;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arr[1] = a - i;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; arr[0] &lt;&lt; " " &lt;&lt; arr[1] &lt;&lt; "\n";
&nbsp; &nbsp; }
}
</code></pre>
<h3 id="🔍-로직-설명" data-ke-size="size23">🔍 로직 설명</h3>
<p data-ke-size="size16">짝수를 어떤 소수의 합으로 나눌 수 있나를 찾는 문제인데 일단 주어진 수가 a라 하면 a/2까지만 탐색을진행하면 된다.<br />어차피 그 이상의 수는 이미 앞에서 구한 케이스와 중복되기 때문 (ex -&gt; 8이라면 3/5 5/3 중복 탐색하게 된다)<br />그래서 2부터 시작해서 (1은 소수가 아니니) 각각의 수와 a-i가 소수인지 확인하는 함수를 만들고 int arr[2]라는 배열에 최신화 한후 구하면된다.</p>
<p data-ke-size="size16">이런식으로 짜면 시간복잡도가 o(t*n* <span style="background-color: #ffffff; color: #555555; text-align: left;">&radic;</span> n))인데 (내 코드로는 o(n*a* <span style="background-color: #ffffff; color: #555555; text-align: left;">&radic;</span> a))</p>
<p data-ke-size="size16">t의 범위가 정해져 있지않아서 t가 엄청 크면 시간초과가 날 수도 있다. 그러나 통과한거보니 주어진 t가 그렇게 크지않은거 같다</p>
<h3 id="✍️-느낀-점" data-ke-size="size23">✍️ 느낀 점</h3>
<p data-ke-size="size16">소수를 구하는 함수중 효율적인 함수가 있어서 가져와 봤다</p>
<pre id="code_1758100129937" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>void sieve() {
    isPrime[0] = isPrime[1] = false;
    for (int p = 2; p * p &lt;= 10000; p++) {
        if (isPrime[p]) {
            for (int i = p * p; i &lt;= 10000; i += p) {
                isPrime[i] = false;
            }
        }
    }
}</code></pre>
<p data-ke-size="size16">수의 약수는 그 수의 제곱근을 넘지않는다는 성질을 이용해 주어진 범위속 최대값 10,000까지 탐색하는데 이 수의 제곱근 까지만 탐색하도록 하였고, 이때 수에 접근후 그 수의 배수들은 모두 소수가 아니다 라는 성질로 bool배열을 최신화한다.</p>
<p data-ke-size="size16">이때 i가 p부터 시작이 아니라 p*p인 이유는 이미 그전수에서 p*2, p*3등의 숫자를 탐색했을것이기 때문에 효율적으로 p*p부터 접근한다. 이러면 각각의 케이스에서 그 수가 소수인지 o(1)정도로 찾을수있다.</p>
<p data-ke-size="size16">이렇게 하면 복잡도가 <span>O</span><span>(</span><span>N</span><span>lo<span>g</span></span><span>lo<span>g</span></span><span>N</span><span>)가 되고 총 t번의 케이스가 n/2만큼 반복될수 있으니 총 <span><span>O</span><span>(</span><span>N</span><span>lo<span>g</span></span><span>lo<span>g</span></span><span>N</span><span>+</span></span><span><span>T</span><span>&sdot;</span></span><span><span>n</span><span>)가 된다</span></span></span></p>
<p data-ke-size="size16">t의 영향을 덜 받는 코드 완성</p></code></pre>