<h2 data-ke-size="size26">백준 5052번 전화번호 목록 (C++)</h2>
<p data-ke-size="size16">이번에 풀어본 문제는 문자열 정렬을 통해 접두어 관계를 효율적으로 찾는 <b>백준 5052번 전화번호 목록</b>입니다. 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하는 문제로, 정렬의 특성을 활용하면 간단하게 해결할 수 있습니다.</p>
<p data-ke-size="size16">문제는 아래 링크에서 확인할 수 있습니다.<br /><a href="https://www.acmicpc.net/problem/5052" target="_blank" rel="noopener noreferrer">백준 5052번 문제 바로가기</a></p>
<h3 id="💻-코드" data-ke-size="size23">💻 코드</h3>
<pre class="arduino"><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main(){
&nbsp; &nbsp; ios_base::sync_with_stdio(false);
&nbsp; &nbsp; cin.tie(NULL);

&nbsp; &nbsp; int t;
&nbsp; &nbsp; cin &gt;&gt; t;

&nbsp; &nbsp; while(t--){
&nbsp; &nbsp; &nbsp; &nbsp; int n;
&nbsp; &nbsp; &nbsp; &nbsp; cin &gt;&gt; n;

&nbsp; &nbsp; &nbsp; &nbsp; vector&lt;string&gt; st;
&nbsp; &nbsp; &nbsp; &nbsp; for(int i = 0; i &lt; n; i++){
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string str;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cin &gt;&gt; str;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; st.push_back(str);
&nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp; sort(st.begin(), st.end());

&nbsp; &nbsp; &nbsp; &nbsp; bool isConsistent = true;
&nbsp; &nbsp; &nbsp; &nbsp; for(int i = 0; i &lt; n - 1; i++){
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 현재 문자열이 다음 문자열의 접두어인지 확인
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(st[i+1].find(st[i]) == 0){
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isConsistent = false;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp; if(isConsistent) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; "YES\n";
&nbsp; &nbsp; &nbsp; &nbsp; } else {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; "NO\n";
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }

&nbsp; &nbsp; return 0;
}
</code></pre>
<h3 id="🔍-로직-설명" data-ke-size="size23">🔍 로직 설명</h3>
<p data-ke-size="size16">처음에 접근한 방식은 find함수를 써서 이중 포문을 돌린뒤 각문자마다 전체 문자를 탐색하여 그 안에 지금 문자가 포함되어있는지 방식으로 짰다. 뭐 짜면서도 느낀거지만 이중&nbsp; 포문이기에 복잡도가 n^2이었고 당연히 시간초과가 나는 코드였다.</p>
<p data-ke-size="size16">다른 방법을 생각해보려고 했는데 뭔가 이문제는 내가 모르는 함수 활용이나 개념으로 풀 수 있는 문제인거 같아서 빠르게 구글을 참고했다.</p>
<p data-ke-size="size16">문자로 된 srting을 정렬했을때 접두어인 부분은 항상 앞에 정렬된다는 사실을 깨달았다 즉</p>
<p data-ke-size="size16">1223 <br />1112<br />1112232</p>
<p data-ke-size="size16">이런 식이라면</p>
<p data-ke-size="size16">1112<br />1112232 <br />1223</p>
<p data-ke-size="size16">요런식으로 정렬된다. 당연하게 앞 문자부터 오름차순으로 정렬되니까 그런것 같다 문자의 길이랑 상관없이!<br />그래서 정렬한다음 i+1 문자열에 i가 접두어인지 한번의 for문으로 확인하면 되는일</p>
<p data-ke-size="size16">그런데 이때 코드를 처음에는 st[i+1].find(st[i]) != string::npos 이런식으로 짰는데 이게 접두어만 확인하는 코드가 아니고 그냥 그 문장안 어디든 st[i]가 포함되어있는지 확인하는 코드였다 그래서 !=sringLLnpos 부분을 == 0으로 바꾸면 접두어인지 확인하는 코드라고 한다(접두어면 0을 반환하다고 하더라 find()함수가..)</p>
<h3 id="✍️-느낀-점" data-ke-size="size23">✍️ 느낀 점</h3>
<p data-ke-size="size16">find함수가 저런식으로 작동한다는것을 알게 되었고 정렬하면 접두어부터 정렬된다는 사실이 꽤 흥미로웠다 사실 알고보면 당연한거지만 처음에 알았을때는 신기했다... 어쨌든 find함수도 다시 한번 제대로 공부해봐야 할듯!</p></code></pre>