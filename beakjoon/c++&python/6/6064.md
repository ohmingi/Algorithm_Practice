## 백준 6064번 카잉 달력 (C++)

이번에 풀어본 문제는 **백준 6064번 카잉 달력**이다.

문제는 아래 링크에서 확인할 수 있다.  
[백준 6064 문제 바로가기](https://www.acmicpc.net/problem/6064)

### 💻 코드

```
#include <iostream>

using namespace std;

int gcd(int m, int n) {
  while (n != 0) {
    int r = m % n;
    m = n;
    n = r;
  }
  return m;
}

int main() {
  int N;
  cin >> N;

  while (N--) {
    int m,n,x,y;
    cin >> m >> n >> x >> y;

    int cnt = x;
    long long limit = m * n / gcd(m, n);

    while (cnt <= limit) {
      if ((cnt - y) % n == 0) {
        cout << cnt << "\n";
        break;
      }
      cnt += m;

      if (cnt > limit) {
        cout << -1 << "\n";
        break;
      }
    }
  }
}
```

### 🔍 로직 설명

처음에 이 문제에 접근했을때는 복잡도 계산을 잘못해서 단순한게 x'과 y'값이 x랑 y가 될때까지 하나하나 반복문 돌면서 했는데, m과 n이 최대 40,000이기에 40,000 \* 40,000 = 1,600,000,000   
즉, 1억이 넘어가기에 시간을 초과하게 된다.

그래서 계속 고민해봤는데 이게 mod연산을 해서 반복되는거 까진 이해를 했으니, 최대공배수랑 mod연산을 어떻게 잘 쓰면 풀릴거같았다.

그렇게 나온게 지금의 코드인데, 이렇게 완성되기 까지도 코드 수정이 꽤있었다. 처음엔 while문의 조건을 어떻게 넣어야할지 고민하다가   
m,n둘의 최대공배수만큼 찍고 다시 처음부터 돌아오니 최대공배수 만큼 조건문을 처리했다. 이때 limit는 long long 으로 해야 오버플로우가 나지 않는다 

그리고 처음에는 y == cnt % n 으로 처리하게 했는데 이렇게 하니까 y의 값이 n이라면 성립할 수 없게 되버린다.  
그렇기에 수정이 필요했고 지금의 (cnt - y) % n == 0 으로 하게 되면 y가 n이더라도 처리된다.

### ✍️ 느낀 점

수학은 머리를 상당히 복잡하게 써야하는 문제인거같다. 그래도 문제에 쓰여지는 방식들이 그렇게 많지는 않은거같기에 기본적인 수학개념들을 잘 다지고 많이 풀다보면 감이 잡힐 거 같다