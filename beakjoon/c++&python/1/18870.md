## 백준 18870번 좌표 압축 (C++)

이번에 풀어본 문제는 **백준 18870번 좌표 압축**이다.

문제는 아래 링크에서 확인할 수 있다.  
[백준 18870 문제 바로가기](https://www.acmicpc.net/problem/18870)

### 💻 코드

```
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>

using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n;
  cin >> n;

  vector<int> v;
  vector<int> v1;
  map<int,int> m;

  for (int i = 0; i < n; i++) {
    int a;
    cin >> a;
    if (m.find(a) == m.end()) {
      v.push_back(a);
    }
    v1.push_back(a);
    m[a] = 1;
  }

  sort(v.begin(), v.end());

  for (int i = 0; i < v.size(); i++) {
    m[v[i]] = i;
  }

  for (int i = 0; i < v1.size(); i++) {
    cout << m[v1[i]] << " ";
  }

}
```

### 🔍 로직 설명

처음 봤을때 좌표 압축 뭐시기 이러길래 이게 뭔말인가 했는데 그냥 자기 보다 작은수가 몇개인지 출력하는 문제였다.  
그래서 인덱스로 접근해서 뭔가 하는거까진 접근을 했는데 그래서 인덱스를 어떻게 출력하고, 중복은 또 어떻게 제거 해야 할지 쉽게 풀리지 않았다.

일단 중복제거는 map을 이용해서 map에 값이 들어있다면, 중복된값을 추가하지않는 백터 한개와 모든 값을 다 저장하고 있는 백터를 두개 선언했다.  
이때 중복제거 조건문을 (m\[key\] = 1) 이런식으로 비교했는데 이러면 맵에 저장되어 있지않은 값에 접근하게 되기 때문에 에러가 나서 find()함수 사용으로 바꿔 주었다.

그 다음 중복제거한 백터를 오름 차순으로 정렬시켜주고 이 백터 사이즈만큼 순회하면서 맵에 key에는 백터의 값을 value에는 인덱스 값을 저장시켰다.   
이렇게 하면 맵 key값마다 저장된 인덱스를 출력할 수 있게 된다

다음 중복을 허용한 백터사이즈만큼 순회하면서 백터의 값들을 맵의 key로 활용하면 각각의 값마다 index를 출력할 수 있게 되고 이게 결국 문제에서 원하는 출력이 된다.

시간 복잡도는 sort -> nlog(n)이고 find -> nlogn이때 find는 n만큼 순회하니 총 O(nlogn)이 된다.

입력값이 많기 때문에 

```
ios::sync_with_stdio(false);
cin.tie(nullptr);
```

를 추가하여 입출력 속도를 향상시켰다.

++

조금 비효율적으로 주먹구구식으로 짠거같아 다른 풀이를 찾아봤는데

중복제거는 erase와 unique함수를 통해 제거하고, 인덱스 순환은 upperbound를 통해 구현하면 더 직관적인 코드가 된다

### ✍️ 느낀 점

이렇게 단순 스킬 없이 구현하는 문제는 오랜만이라 그런지 조금 많이 헤멨다.  
그래도 인덱스 접근까지는 꽤 빨리 생각해내서 다음부터 이런문제는 빨리 해결 가능할 것 같다.