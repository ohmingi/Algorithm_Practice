<h2 data-ke-size="size26">백준 1715번 카드 정렬하기 (C++)</h2>
<p data-ke-size="size16">이번 문제는 <b>그리디 알고리즘</b>과 <b>우선순위 큐</b>를 사용해 해결하는 <b>백준 1715번 카드 정렬하기</b>입니다. 🃏 여러 개의 카드 묶음을 하나로 합칠 때 필요한 최소 비교 횟수를 구하는 문제입니다.</p>
<hr data-ke-style="style1" />
<p data-ke-size="size16">문제는 아래 링크에서 확인할 수 있습니다.<br /><a href="https://www.acmicpc.net/problem/1715" target="_blank" rel="noopener noreferrer">백준 1715번 문제 바로가기</a></p>
<hr data-ke-style="style1" />
<h3 id="💻-코드" data-ke-size="size23">💻 코드</h3>
<pre class="arduino"><code>#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;

int main(){
&nbsp; &nbsp; int n;
&nbsp; &nbsp; cin &gt;&gt; n;

&nbsp; &nbsp; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;
&nbsp; &nbsp;
&nbsp; &nbsp; for(int i = 0; i &lt; n; i++){
&nbsp; &nbsp; &nbsp; &nbsp; int a;
&nbsp; &nbsp; &nbsp; &nbsp; cin &gt;&gt; a;
&nbsp; &nbsp; &nbsp; &nbsp; q.push(a);
&nbsp; &nbsp; }

&nbsp; &nbsp; if(q.size() == 1){
&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; 0;
&nbsp; &nbsp; &nbsp; &nbsp; return 0;
&nbsp; &nbsp; }

&nbsp; &nbsp; int cnt = 0;

&nbsp; &nbsp; while(q.size() &gt; 1){
&nbsp; &nbsp; &nbsp; &nbsp; int a,b;
&nbsp; &nbsp; &nbsp; &nbsp; a = q.top();
&nbsp; &nbsp; &nbsp; &nbsp; q.pop();
&nbsp; &nbsp; &nbsp; &nbsp; b = q.top();
&nbsp; &nbsp; &nbsp; &nbsp; q.pop();
&nbsp; &nbsp; &nbsp; &nbsp; cnt += a + b;
&nbsp; &nbsp; &nbsp; &nbsp; q.push(a + b);
&nbsp; &nbsp; }

&nbsp; &nbsp; cout &lt;&lt; cnt;
}
</code></pre>
<hr data-ke-style="style1" />
<h3 id="🔍-로직-설명" data-ke-size="size23">🔍 로직 설명</h3>
<p data-ke-size="size16">처음에는 단순하게 백터로 작은순데로 정렬하고 계산하고 그 계산한값에 그다음 작은값을 계산하는 방식으로 했는데 틀렸다.<br />내 뇌로는 왜 틀린지 이해가 안되서 고생좀 했다.<br />알고보니 내가 계산한값 즉 10+20을 해서 만들어진 30또한 배열에 넣어서 이 30또한 포함해서 다시 작은순서대로 정렬해서 계산해야하는 문제였다<br />그렇다면 최소힙을 써야하는 문제 우선수위큐는 기본적으로 최대힙이니 greater&lt;int&gt;를 사용해서 최소힙으로 변경 후 넣고 빼고 계산하면 풀리는 문제다 시간복잡도는 처음에 n만큼 push하니 o(nlogn)이고 그다음 while문에서 n-1만큼 넣고 빼고 하니 똑같이&nbsp;<br />O(nlogn)이라서 더해주면 O(nlogn)이 나오게 된다</p>
<hr data-ke-style="style1" />
<h3 id="✍️-느낀-점" data-ke-size="size23">✍️ 느낀 점</h3>
<p data-ke-size="size16">그리디 알고리즘 풀땐 최근에 느낀건데 문제 해석이 중요하고 수학적으로 이상하게 풀어도 테스트케이스는 맞는 경우가 많으니까 더 고민해서 이게 과연 문제가 원하는 풀이가 맞는지, 다른 경우들 혹은 과정들 빼고 풀어버린게 아닐지 고민많이해야 할것 같은 유형이다</p></code></pre>