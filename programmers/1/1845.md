## 프로그래머스 1845번 폰켓몬 (C++)

이번에 풀어본 문제는 **프로그래머스 1845번 폰켓몬**이다.

문제는 아래 링크에서 확인할 수 있다.  
[https://school.programmers.co.kr/learn/courses/30/lessons/1845](https://school.programmers.co.kr/learn/courses/30/lessons/1845)

### 💻 코드

```
#include <vector>
#include <algorithm>

using namespace std;

int solution(vector<int> nums)
{
    int answer = 0;
    
    vector<int> v;
    
    for(int i = 0; i < nums.size(); i++){
        auto it = find(v.begin(), v.end(), nums[i]);
        
        if(it == v.end()){
            answer++;
            v.push_back(nums[i]);
        }

    }
    
    if(answer > nums.size() / 2){
        answer = nums.size() / 2;
    }
    return answer;
}
```

### 🔍 로직 설명

처음 문제를 봤을때 중요한건 단순 무식하게 모든 경우의수를 따지려고 하지 않는다는 것이다

지금의 내 수준을 따져보면 한번에 답에 가까운 로직이 생각나기 보다는 단순 무식한 방법 먼저 떠오른다.

(그렇기에 오히려 역설적으로 그 첫번째 생각을 무조건 배제하고 생각하니 방법이 더 잘 떠오르는것 같기도하다)

여기서 핵심은 n에 대하여 n/2만큼 나눠서 뽑았을때 최대로 뽑을 수 있는 중복되지않는 숫자가 몇개냐라는 해석이 가능해야 한다.

여기까지 도달했다면 굉장히 로직은 쉬워진다. 겹치지않는 수가 배열에 몇개인지를 계산을 하고 이것이 n/2보다 작으면 그것이 정답이 되고 초과한다면 n/2가 정답이 된다.

즉 8개 중 5개가 중복되지않는 수라고 했을때 답은 반절인 4가 되고, 8개 중 중복되지않는 수가 3개라고 했을때 어떻게 뽑든 최대 3밖에 나오지 않는다.

사실 내 코드는 되게 비효율적이다 N^2의 시간복잡도를 가진다

unordered\_set을 사용하면 N 시간안에 답을 찾을 수 있다.

```
#include <vector>
#include <unordered_set> 
#include <algorithm>

using namespace std;

int solution(vector<int> nums)
{
    unordered_set<int> s(nums.begin(), nums.end());
    
    return min(s.size(), nums.size() / 2);
}
```

### ✍️ 느낀 점

뭔가 쉬워보이는 문제는 풀었더라도 최대한의 효율성을 생각해보는 연습을 할 것